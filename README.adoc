---
tags: [spring-cloud, hystrix]
projects: [spring-cloud, spring-cloud-netflix]
---
:spring_version: current
:spring_boot_version: 1.2.8.RELEASE
:toc:
:icons: font
:source-highlighter: prettify
:project_id: gs-circuit-breaker
本指南将带你一步一步了解，使用Netflix Hystrix 默认的容错库，为存在潜在错误的方法应用断路器。

== 你将构建什么

你会建立一个使用 http://martinfowler.com/bliki/CircuitBreaker.html[断路器模式] 优雅地将功能降级，当一个方法调用失败的时候。使用断路器模式可以让一个微服务在相关的服务失败时继续运行，防止失败的级联与给失败的服务恢复时间。


== 你需要什么

:java_version: 1.8
include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/how_to_complete_this_guide.adoc[]

[[reveal-gradle]]
[.reveal-gradle]
== 使用Gradle构建

[[scratch]]
[.use-gradle]
== 使用Gradle构建

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_both_builds.adoc[]

`bookstore/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/bookstore/build.gradle[]
----

`reading/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::https://raw.githubusercontent.com/swebGoBetter/{project_id}/master/initial/reading/build.gradle[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-gradle-plugin.adoc[]

[[reveal-maven]]
[.reveal-maven]
== 使用Maven构建

[[use-maven]]
[.use-maven]
== 使用Maven构建

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro_maven.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

`bookstore/pom.xml`
[source,xml]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/bookstore/pom.xml[]
----

`reading/pom.xml`
[source,xml]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/reading/pom.xml[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-maven-plugin.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/hide-show-sts.adoc[]



[[initial]]
== 建立一个服务器端微服务应用

书店服务将有一个端点。它可以在 `/recommended` 中访问，并且（为了简单起见）返回一个 `String` 推荐阅读列表。

编辑我们的主类，在 `BookstoreApplication.java` 。应该是这样的：

`bookstore/src/main/java/hello/BookstoreApplication.java`
[source,java]
----
include::complete/bookstore/src/main/java/hello/BookstoreApplication.java[]
----

`@RestController` 注释标记 `BookstoreApplication` 作为一个控制器类，像 `@Controller` 一样，也确保 `@RequestMapping` 方法在这个类中的行为好像有 `@ResponseBody` 注解一样。那就是，在这类中的 `@RequestMapping` 方法的返回值将从原来的类型被自动转换成适当的类型然后将直接写入响应体。

我们将在客户端服务应用程序的本地运行此应用程序，因此在 `src/main/resources/application.properties` 属性中，设置 `server.port` ，以便当我们运行该服务时，书店服务不与客户端发生冲突。

`bookstore/src/main/resources/application.properties`
[source,properties]
----
include::complete/bookstore/src/main/resources/application.properties[]
----

== 建立一个客户端微服务应用

阅读应用程序将是我们对书店应用程序的前端。我们将可以在 `/to-read` 中查看我们的阅读列表，阅读列表将从书店服务应用程序获取数据。T

`reading/src/main/java/hello/ReadingApplication.java`
[source,java]
----
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.client.RestTemplate;
import java.net.URI;

@RestController
@SpringBootApplication
public class ReadingApplication {

  @RequestMapping("/to-read")
  public String readingList() {
    RestTemplate restTemplate = new RestTemplate();
    URI uri = URI.create("http://localhost:8090/recommended");

    return restTemplate.getForObject(uri, String.class);
  }

  public static void main(String[] args) {
    SpringApplication.run(ReadingApplication.class, args);
  }
}
----

为了从书店得到的列表，我们用春天的 `RestTemplate` 模板类。 `RestTemplate` 使用HTTP GET请求到书店服务的URL,这个是我们提供的URL,然后返回一个 `String`。（欲了解更多关于使用Spring使用REST式服务的信息，请参见下面的 http://knos.top/guides/gs/consuming-rest/[Consuming a RESTful Web Service] 指南）。

添加 `server.port` 属性到 `src/main/resources/application.properties`:

`reading/src/main/resources/application.properties`
[source,properties]
----
include::complete/reading/src/main/resources/application.properties[]
----

We now can access, in a browser, the `/to-read` endpoint on our Reading application, and see our reading list. Yet since we rely on the Bookstore application, if anything happens to it, or if Reading is simply unable to access Bookstore, we'll have no list and our users will get a nasty HTTP 500 error message.

== 应用断路器模式

Netflix's Hystrix library provides an implementation of the Circuit Breaker pattern: when we apply a circuit breaker to a method, Hystrix watches for failing calls to that method, and if failures build up to a threshold, Hystrix opens the circuit so that subsequent calls automatically fail. While the circuit is open, Hystrix redirects calls to the method, and they're passed on to our specified fallback method.

Spring Cloud Netflix Hystrix looks for any method annotated with the `@HystrixCommand` annotation, and wraps that method in a proxy connected to a circuit breaker so that Hystrix can monitor it. This currently only works in a class marked with `@Component` or `@Service`, so in the Reading application, under `src/main/java/hello`, add a new class: `BookService`.

The `RestTemplate` will be injected into the constructor of the `BookService` when it is created. The complete class should look like this:

`reading/src/main/java/hello/BookService.java`
[source,java]
----
include::complete/reading/src/main/java/hello/BookService.java[]
----

We've applied `@HystrixCommand` to our original `readingList()` method. We also have a new method here: `reliable()`. The `@HystrixCommand` annotation has `reliable` as its `fallbackMethod`, so if, for some reason, Hystrix opens the circuit on `readingList()`, we'll have an excellent (if short) placeholder reading list ready for our users.

In our main class, `ReadingApplication`, we will create a `RestTemplate` bean, inject the `BookService` and call it for our reading list:

`reading/src/main/java/hello/ReadingApplication.java`
[source,java]
----
include::complete/reading/src/main/java/hello/ReadingApplication.java[]
----

Now, to retrieve the list from the Bookstore service, we call `bookService.readingList()`. You'll also notice that we've added one last annotation, `@EnableCircuitBreaker`; that's necessary to tell Spring Cloud that the Reading application uses circuit breakers and to enable their monitoring, opening, and closing (behavior supplied, in our case, by Hystrix).

== 试试

Run both the Bookstore service and the Reading service, and then open a browser to the Reading service, at `localhost:8080/to-read`. You should see the complete recommended reading list:

----
Spring in Action (Manning), Cloud Native Java (O'Reilly), Learning Spring Boot (Packt)
----

Now shut down the Bookstore application. Our list source is gone, but thanks to Hystrix and Spring Cloud Netflix, we have a reliable abbreviated list to stand in the gap; you should see:

----
Cloud Native Java (O'Reilly)
----

== 总结

Congratulations! You've just developed a Spring application that uses the Circuit Breaker pattern to protect against cascading failures and to provide fallback behavior for potentially failing calls.




include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/footer.adoc[]
